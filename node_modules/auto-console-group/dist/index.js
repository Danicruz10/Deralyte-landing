/*!
 *  @module      auto-console-group v1.3.0
 *
 *  @description Automagically group console logs in the browser console.
 *
 *  @author      David J. Bradshaw <info@iframe-resizer.com>
 *  @see         {@link https://github.com/davidjbradshaw/auto-console-group#readme}
 *  @license     MIT
 *
 *  @copyright  (c) 2025, David J. Bradshaw. All rights reserved.
 */

const $ = "font-weight: normal;", F = "font-weight: bold;", H = "font-style: italic;", U = $ + H, N = "color: #135CD2;", S = "color: #A9C7FB;", k = "color: #1F1F1F;", j = "color: #E3E3E3;", f = "default", Q = "error", C = "log", _ = Object.freeze({
  assert: !0,
  error: !0,
  warn: !0
}), L = {
  expand: !1,
  defaultEvent: void 0,
  event: void 0,
  label: "AutoConsoleGroup",
  showTime: !0
}, q = {
  profile: 0,
  profileEnd: 0,
  timeStamp: 0,
  trace: 0
}, P = (o) => {
  const t = o.event || o.defaultEvent;
  return t ? `${t}` : "";
}, u = Object.assign(console);
function V() {
  const o = /* @__PURE__ */ new Date(), t = (l, d) => o[l]().toString().padStart(d, "0"), s = t("getHours", 2), c = t("getMinutes", 2), r = t("getSeconds", 2), i = t("getMilliseconds", 3);
  return `@ ${s}:${c}:${r}.${i}`;
}
const { fromEntries: W, keys: b } = Object, z = (o) => [
  o,
  u[o]
], K = (o) => (t) => [
  t,
  function(s) {
    o[t] = s;
  }
], h = (o, t) => W(b(o).map(t));
function X(o = {}) {
  const t = {}, s = {}, c = [], r = {
    ...L,
    // @ts-expect-error: backwards compatibility
    expand: !o.collapsed || L.expanded,
    ...o
  };
  let i = "";
  function l() {
    c.length = 0, i = "";
  }
  function d() {
    delete r.event, l();
  }
  const v = () => c.some(([e]) => e in _), O = () => v() ? !0 : !!r.expand, A = () => r.showTime ? i : "";
  function g() {
    if (c.length === 0) {
      d();
      return;
    }
    u[O() ? "group" : "groupCollapsed"](
      `%c${r.label}%c ${P(r)} %c${A()}`,
      $,
      F,
      U
    );
    for (const [e, ...n] of c)
      u.assert(
        e in u,
        `Unknown console method: ${e}`
      ), e in u && u[e](...n);
    u.groupEnd(), d();
  }
  function p() {
    i === "" && (i = V(), queueMicrotask(() => queueMicrotask(g)));
  }
  function G(e) {
    p(), r.event = e;
  }
  function a(e, ...n) {
    c.length === 0 && p(), c.push([e, ...n]);
  }
  const D = (e) => (...n) => {
    let m;
    try {
      m = e(...n);
    } catch (E) {
      if (!Error.prototype.isPrototypeOf(E)) throw E;
      a(Q, E), g();
    }
    return m;
  };
  function M(e, ...n) {
    e !== !0 && a("assert", e, ...n);
  }
  function I(e = f) {
    s[e] ? s[e] += 1 : s[e] = 1, a(C, `${e}: ${s[e]}`);
  }
  function R(e = f) {
    delete s[e];
  }
  function x(e = f) {
    p(), t[e] = performance.now();
  }
  function w(e = f, ...n) {
    if (!t[e]) {
      a("timeLog", e, ...n);
      return;
    }
    const m = performance.now() - t[e];
    a(C, `${e}: ${m} ms`, ...n);
  }
  function y(e = f) {
    w(e), delete t[e];
  }
  const B = (e) => [
    e,
    (...n) => a(e, ...n)
  ];
  return {
    ...h(r, K(r)),
    ...h(console, B),
    ...h(q, z),
    assert: M,
    count: I,
    countReset: R,
    endAutoGroup: g,
    errorBoundary: D,
    event: G,
    purge: l,
    time: x,
    timeEnd: y,
    timeLog: w,
    touch: p
  };
}
const T = typeof window > "u" || typeof window.matchMedia != "function" ? !1 : window.matchMedia("(prefers-color-scheme: dark)").matches, J = T ? S : N, Y = T ? j : k;
export {
  F as BOLD,
  Y as FOREGROUND,
  J as HIGHLIGHT,
  H as ITALIC,
  $ as NORMAL,
  X as default
};
